#{
    This is the completed version of line_drone.tree. Start with that file.
    
    Unsurprisingly, you are currently reading a comment. Comments are written by starting # { (no space) and ended through a } # (no space). Comments cannot be nested.
    
    Some notes:
    Indentation is optional, but suggested (for clarity).
    Spacing is suggested, but mostly optional. Thus result{0} and result { 0 } are both acceptable. Spacing between alphanumeric strings is required (i.e. helloworld and hello world are not the same).
    New lines are always optional, but suggested.
    If braces get too nested, you can start closing them in a more verbose manner.
    E.g.
    composite {...}
    and
    composite {...} end_composite
    are both acceptable.
    
    Code:
    At various points, you will need to specify values. In these cases, we utilize code statements, which generally look as follows
    CONSTANT | VARIABLE | (func, val1, val2, ... valk)
    To be clear, this means your code can be a constant, a variable, or a function call.
    Each val can be another code statement, so nesting is possible. You may always include more parantheses.
    For instance, to add 7 to a variable x and take the remainder of division by 3, you would do the following
    (mod, (add, x, 7), 3).
    See the readme for a list of all supported functions.
    
    Sections:
    These files are split into several sections
    the sections are as follows
    configuration - here you can set up various configurations for the tree, such as if neural networks are used.
    enumerations - here you declare all enumerations to be used
    constants - here you declare all constants to be used
    variables - here you declare all variables to be used, and set the initial values
    environment_update - here you declare how environment variables change over time
    checks - here you set up check nodes that don't use the environment
    environment_checks - here you set up check nodes that do use the environment
    actions - here you set up action nodes
    sub_trees - subtrees are to help keep the tree readable.
    tree - here you declare the structure of the tree
    tick_prerequisite - here you declare a condition that must be met for the tree to tick
    specifications - here you declare specifications to be met.


    each section may be empty, except tick_prerequiste. If you want the tree to tick no matter what, simply have your condition be True.
}#
configuration {} #{You don't need to do anything with configuration}#
enumerations {} #{You don't need to do anything with enumerations}#
constants {
    min_val := -5,
    max_val := 10
    #{Declare an integer constant max_val. Make sure min_val is less than max_val! Constant declarations are comma seperated.}#
} 
variables {
    variable {
	bl #{this is a blackaboard variable}#
	position #{name of the variable}#
	VAR #{this variable is stateful}#
	[min_val, max_val] #{variable domain}#
	assign{
	    result{
		0
	    }
	}
    }
    variable {
	env #{this is an environment variable}#
	goal #{name of the variable}#
	VAR #{this variable is stateful}#
	[min_val, max_val] #{variable domain}#
	assign{
	    result{
		min_val, max_val #{nondeterministically choose}#
	    }
	}
    }
}

environment_update {
    variable_statement {
	goal #{variable we are updating}#
	assign {
	    case {
		(eq, goal, position)
		#{Fill in a condition here for checking if we reached the goal. Recall that we write functions as (func, val1, val2). eq is the function for equality}#
	    }
	    result {
		(loop, index_var, [min_val, max_val] such_that True, index_var)
		#{This uses a loop to set any value between min_val and max_val}#
		#{If the condition is met, we assign this value. Since the condition is we reached the goal, we need to set a new goal. Try setting a new goal to reach. To assign nondeterministically, write down multiple values (comma seperated)}#
	    }
	    result {
		goal
		#{If the condition is not met, do not change the value. Remember that you can write down the variable name to use its value}#
	    }
	}
    }
}

checks {} #{Nothing to do here}#

environment_checks {
    environment_check {
	less_than #{the ID of the node}#
	arguments {} #{no arguments}#
	read_variables {position} #{list all blackboard variables that are used}#
	condition {(lt, position, goal)} #{If the condition is true, node returns success, otherwise failure.}#
    }
    environment_check {
	greater_than #{the ID of the node}#
	arguments {} #{no arguments}#
	read_variables {position} #{list all blackboard variables that are used}#
	condition {(gt, position, goal)} #{If the condition is true, node returns success, otherwise failure.}#
    }
    #{Create another environment check, this one named greater_than. It should check if position is greater than goal}#
}

actions {
    action {
	move #{ID of the action}#
	arguments {change := INT}
	local_variables {} #{none}#
	read_variables {} #{none}#
	write_variables {position} #{we will update this variable}#
	initial_values {} #{only applies to local variables, and we have none}#
	update {
	    variable_statement{
		position
		assign {
		    result {
			(min, max_val, (max, min_val, (add, position, change)))
		    }
		}
	    }
	    #{Create a variable statement that updates the value of position by adding change. Look at the environment_update section to see how a variable_statement is written}#
	    return_statement {result{success}} #{The node returns success}#
	}
    }
}
sub_trees {} #{Not used}#
tree {
    #{
	Create a stree using the following structure
	                      sel
	                /             \
                 seq1                       seq2
                 /  \                       /  \
	less_than    moveR      greater_than   moveL

	That is to say, the root should be a selector named sel.
	It should have to children, seq1 and seq2, both of which are sequences.
	seq1 should have two children, less_than and moveR
	seq2 should have two children, greater_than and moveL
	moveL and moveR should be based on move.

	General format is
	composite {
	    NODE_NAME
	    NODE_TYPE
	    children {
		...
	    }
	}
	the ... is to be replaced with another node. This ends up being nested in this case.
	For leaf nodes, there are the following options
	NODE_ID {ARGUMENTS}
	NODE_NAME : NODE_ID {ARGUMENTS}
	If the same node is used multiple times, you must used NODE_NAME : NODE_ID {ARGUMENTS} to avoid naming colisions.
	If there are no arguments, simply write {}

	Thus, for instance
	composite {
	    a
	    selector
	    children {
		composite {
		    b
		    sequence {
			c {1}
			d : e {}
		    }
		    f : e {}
		}
	    }
	}
	produces the following tree
	     a
	    / \
          b    f
         /\
	c  d
	Where c has argument 1 and d and f use the same node template. 
    }#
    composite {
	sel
	selector
	children {
	    composite {
		seq1
		sequence
		children {
		    less_than {}
		    moveR : move {1}
		}
	    }
	    composite {
		seq2
		sequence
		children {
		    greater_than {}
		    moveL : move {-1}
		}
	    }
	}    
    }
}

tick_prerequisite {
    True #{Always tick}# 
}

specifications {
    CTLSPEC {
	(always_globally, (always_finally, (eq, position at -1, goal at 0)))
    }
}